(*             v1                  *)
(* very simple ocaml language      *)

implementation ::= [ module-items ]
module ::= definition | expr

definition	::=	'let' ['rec'] let-binding { 'and' let-binding }

(*                     raw grammar                 *)
expr ::= constant                                  # ConstantExpr
| '(' expr ')'                                     # ParenExpr
| expr { argument }+                               # CallExpr
| expr infix-op expr                               # BinaryExpr
| 'if' expr 'then' expr [ 'else' expr ]            # CondExpr
| 'let' [ 'rec' ] let-binding { 'and' let-binding } 'in' expr                   # LetBindingExpr
| lowercase-ident                                  # ObjectExpr
(*                     end grammar                 *)

# rewrite rules
expr ::= unary binoprhs
binoprhs ::= ('+' unary)*

unary ::= primary
| '-' primary

primary ::= identexpr  # CallExpr,  ObjectExpr
| numberexpr  # ConstantExpr
| parenexpr # '(' expr ')'   
| 'let' [ 'rec' ] let-binding { 'and' let-binding } 'in' expr                   # LetBindingExpr

identexpr ::= ident
| ident '(' expr* ')'

parenexpr ::= '(' expr ')'
# end rewrite



eof ::= ';;' | EOF                                 # tok_eof

constant ::= integer-literal                       # tok_int
| 'false'                                          # tok_false
| 'true'                                           # tok_true
| '()'                                             # tok_unit

argument ::= expr                                  # Argument

integer-literal ::= [ '-' ]( digit ){ digit | '_' }

digit ::= '0-9'

infix-op ::= 
| '+'                                               # AddOp
| '-'                                               # SubOp
| '*'                                               # MulOp
| '/'                                               # DivOp
| '='                                               # EqOp
| '<'                                               # LtOp
| '>'                                               # GtOp
| '<='                                              # LeOp
| '>='                                              # GeOp
| '<>'                                              # NeOp

let-binding ::= pattern '=' expr                   # LetPatternBinding
| value-name { parameter } '=' expr                # LetFunctionBinding 

parameter ::= pattern                              # Parameter

pattern ::= value-name                             # ValueNamePattern
| '_'                                              # DefaultPattern
| constant                                         # ConstantPattern
| pattern 'as' value-name                          # AsPattern
| '(' pattern ')'                                  # ParenPattern
| pattern '|' pattern                              # UnionPattern


value-name ::= lowercase-ident                     # LowercaseIdent

lowercase-ident ::= ( 'a-z' | '_' ){ letter | digit | '_' }
letter  ::=	'A-Z' | 'a-z'

object-expr ::= lowercase-ident                    # ObjectExpr